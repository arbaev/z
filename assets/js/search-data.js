var store = [{
        "title": "Шпаргалка по InDesign",
        "excerpt":"Концепция “объект и кадр”.Объект может быть любой формы. ctrl-D - импорт картинок, одной или нескольких. вставка происходит по очереди, смена очереди - стрелки лево-право. Если зажать ctrl, то вставятся сразу все картинки сеткой V - черная стрелка - двигает объектA - белая стрелка - двигает кадр A-Master - общая подложка под все страницы, нижний слой Library - сохранять свои темплейты, перед этим удалив с них фото Включить в настройках high performance для качественных превьюшек фото. w - быстрый предпросмотрshift-w - полный предпросмотр ctrl-2 (3) - приблизить к выбранному объекту,ctrl-0 - масштаб страницы на экран,ctrl-alt-0 - разворот на экран ctrl-[, ctrl-] - слой вверх/вниз ctrl-e - пропорционально вписать картинку в объект (обрезка)ctrl-shift-e - уменьшить картинку по размерам объекта (поля)ctrl-shift-c - центрировать картинку в объектеalt-e - изменить размер объекта по размеру картинки ctrl-alt-shift-v - вставить скопированную картинку в объект ctrl-b — свойства объекта, в том числе паддинги Пара из этих шорткатов — нестандартные, кастомизировал сам. Файл с моими шорткатами ","categories": [],
        "tags": ["indesign"],
        "url": "https://arbaev.github.io/z/2018/08/09/InDesign-cheatsheet.html"
      },{
        "title": "Список книг для почитать",
        "excerpt":"добавлено 15.04.2019##Джо Диспенза “Сила подсознания”   мне хотелось меняться, но я не знала как. Пока мне не попала в руки эта книга. Она всегда попадает к своему читателю вовремя. ","categories": [],
        "tags": ["books"],
        "url": "https://arbaev.github.io/z/2019/01/01/books-to-read.html"
      },{
        "title": "Rails: Настройка хранилища Amazon S3 и включение direct upload",
        "excerpt":"Первые три шага делаем согласно этому мануалу: Setting up Rails 5 Active Storage with Amazon S3   Зарегистрироваться на Amazon AWS  Создать Bucket (сервис S3)  Настроить пользователя для доступа к файлам (сервис IAM)      В config/storage.yml раскомментировать блок amazon:, указать имя бакета и псевдоним сервера. Обратить внимание на пробелы после раскомментирования строк. В каждой строке будет лишний пробел, который приводит к ошибке. Его надо удалить.         Полученные ключи доступа прописать в Rails credentials. Действуем по мануалу Rails 5.2 credentials.     Прописать в Gemgile gem AWS SDK for Ruby    gem 'aws-sdk', '~&gt; 3'# Если нужна только поддержка S3, можно установить только этот модульgem 'aws-sdk-s3', '~&gt; 1'        В файлах config/environments поменять настройку с :local на :amazon    #config.active_storage.service = :localconfig.active_storage.service = :amazon            Настроить права CORS  1) Открываем вкладку с бакетами, выбираем нужный  2) Выбрать раздел Permissions, перейти на вкладку CORS configuration  3) Вписать туда следующие строки:      &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;CORSConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\"&gt; &lt;CORSRule&gt;     &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;     &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;     &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;     &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt; &lt;/CORSRule&gt; &lt;CORSRule&gt;     &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;     &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;     &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt;     &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;     &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt; &lt;/CORSRule&gt; &lt;/CORSConfiguration&gt;        4) Когда разработка будет закончена, стоит поменять права на допуск только с нашего сайта, то есть заменить строки AllowedOrigin:      &lt;AllowedOrigin&gt;https://*.mysite.com&lt;/AllowedOrigin&gt;      На этом настройка S3 закончена, файлы должны успешно загружаться. Настройка direct uploads Действуем по мануалу Прямые загрузкиА именно: 9. К полям загрузки в форме добавить аттрибут direct_upload: true 10. Создать файлы direct_upload.js и direct_upload.scss с содержимым из мануала выше. Убедиться, что файлы подключились. Прямая загрузка на S3 должна работать. ","categories": [],
        "tags": ["aws","rails"],
        "url": "https://arbaev.github.io/z/2019/04/17/rails5-amazon-s3-direct-uploads.html"
      },{
        "title": "Кодинг без ифов",
        "excerpt":"Перевод статьи coding without ifs То, что усложняет код больше всего на свете - это условная логика. Она усложняет код больше всего на свете. Все эти if, else, unless, как вложенные, так и не вложенные. Я всегда стараюсь избавиться от них где можно, потому что код без них легче читается и имеет лучший ритм. Сравните это: def update_subscriptions  Subscription.find(:all).each do |each|    if each.expired?      each.renew!    else      each.update!    end  endendс этим: def update_subscriptions  subscriptions = Subscription.find :all  expired = subscriptions.select { |each| each.expired? }  expired.each { |each| each.renew! }  active = subscriptions.reject { |each| each.expired? }  active.each { |each| each.update! }endВ приведенном выше коде об условной логике позаботились исчисляемые методы #select и #reject. Получается, мы переместили условную логику внутрь Ркби из нашего кода. Посмотрите, как во втором примере код просто спокойно течет вверх и вниз, без всяких отступов и ответвлений, его очень легко читать. Даже не программисты выбрали бы второй пример как более простой и элегантный.Еще пример. Скажем, фильтры контроллера в Rails работали так: class EventsController &lt; ApplicationController  def new  end  def create  end  def index  end  def show  end  private  def filter    if action_name == 'new' || action_name == 'create'      authenticate    end  end  # или через поиск в литерале  def filter    if %w(new create).include?(action_name)      authenticate    end  end  def authenticate    unless session[:user_id]      redirect_to login_url    end  endendВ методе #filter нужно условие, потому что мы хотим, чтобы юзер был залогинен для экшенов #new и #create. Однако, рельсовые методы фильтра поддерживают только ключ-параметр. Значит, можно переписать это дело используя метод класса #before_action: class EventsController &lt; ApplicationController  before_action :authenticate, :only =&gt; [:new, :create]  def new  end  def create  end  def index  end  def show  end  private  def authenticate    unless session[:user_id]      redirect_to login_url    end  endendЗдорово. В этот раз мы передвинули условную логику в нутро фреймворка. Где-то там в глубинах Рельс #before_action содержит иф, а в нашем коде его на один меньше. Валидации ActiveRecord::Base этот метод тоже поддерживают. Скажем, при регистрации на нашем сайте указывать возраст не обязательно, но если указали, то он должен быть между 18 и 30. class User &lt; ActiveRecord::Base  def validate    if !age.blank?      if ! (18..30).include?(age)        errors.add :age, 'must be between 18 and 30'      end    end  endendЧёрт ногу сломит, всё в ифах. К счастью, нам помогут методы валидации класса ActiveRecord::Base: class User &lt; ActiveRecord::Base  validates_inclusion_of :age,    :allow_nil =&gt; true,    :in =&gt; 18..30,    :message =&gt; 'must be between 18 and 30'endНамного лучше. Сейчас рельсовый хелпер #validates_inclusion_of содержит два ифа, а наш код — нуль. Забавно, что колбэки ActiveRecord::Base не поддерживают параметр if. Ещё пример. Допустим, в нашем приложении есть публикации. Публикации бывают двух типов, скажем ABC и XYZ. Сейчас информация о публикациях ABC и XYZ предоставляется их собственными сайтами, так что нам надо сделать запрос о них черех HTTP. Публикации мы храним у себя, чтобы не запрашивать их с удалённого сервера каждый раз. И в данном случае нам не нужно беспокоится о синхронизации, потому что публикации никогда не меняются. class Publication &lt; ActiveRecord::Base  def before_create    if type == 'ABC'      # название достаточно уникально, чтобы можно было по нему найти публикацию      self.attributes = AbcGateway.find name    end    if type == 'XYZ'      # название достаточно уникально, чтобы можно было по нему найти публикацию      self.attributes = XyzGateway.find name    end  endendОпять убогие условия. Я хочу отдать разбираться с ними Рельсам, используя метод класса #before_create вместо переопределения инстанс метода. class Publication &lt; ActiveRecord::Base  before_create :abc, :if =&gt; Proc.new { |publication| publication.type == 'ABC' }  before_create :xyz, :if =&gt; Proc.new { |publication| publication.type == 'XYZ' }  def abc    self.attributes = AbcGateway.find name  end  def xyz    self.attributes = XyzGateway.find name  endendТак-то лучше! Есть ещё кусочек синтаксического сахара, о котором я не позаботился. Мой первый пример можно переписать более компактно: def update_subscriptions  Subscription.find(:all).each do |each|    each.renew! if each.expired?    each.update! unless each.expired?  endendНо так мне не нравится, потому что код выглядит будто в нём нет условной логики, а она есть. Просто операторы if и unless скрылись в конце строк. Если уж логики не избежать, её должно быть хорошо видно. Пусть останется напоминание, что в этом месте можно кое-что отрефакторить. Тоже самое делает старый добрый тернарный оператор: def update_subscriptions  Subscription.find(:all).each do |each|    each.expired? ? each.renew! : each.update!  endendДаже короче получилось. Но опять неочевидная условная логика. К тому же двойной ‘?’ выглядит крайне убого. ","categories": [],
        "tags": ["ruby"],
        "url": "https://arbaev.github.io/z/2019/04/22/coding-without-ifs.html"
      },{
        "title": "Ruby: методы sort и sort_by",
        "excerpt":"В Ruby у класса Enumerable есть методы sort и sort_by. Первый выполняет простую сортировку массива. А вот второй более интересен.Sort_by передаёт в блок элементы один за другим, как это делает map, например. Но как, имея один объект из множества, отсортировать всё множество? Загадочный метод. В нём используется преобразование Шварца. Хитрость в том, что данные сначала проходят через наш блок и результаты вычислений заносится во временный массив попарно. Затем временный массив сортируется и получаем из него исходные данные в нужном порядке.Например, имеем массив строк: ary = ['seven', 'five', 'twelve', 'one']# отсортируем по длине строкиary.sort_by(&amp;:length)Шаг 1, сначала происходит вычисление данных во временный массив ary.map { |x| [x.length, x] } # =&gt; [[5, \"seven\"], [4, \"five\"], [6, \"twelve\"], [3, \"one\"]]Шаг 2, делается обычная сортировка ary.sort{ |x,y| x[0] &lt;=&gt; y[0] } # =&gt; [[3, \"one\"], [4, \"five\"], [5, \"seven\"], [6, \"twelve\"]]Шаг 3, получаем отсортированный массив ary.map{ |x,y| y } # =&gt; [\"one\", \"five\", \"seven\", \"twelve\"]Таким образом, можно писать замысловатые правила сортировки весьма элегантно. Например, мне надо было сделать следующую сортировку: ответы на вопрос по дате обновления, но первым должен быть лучший ответ, id которого указан в ресурсе вопроса. Для правильной сортировки мне оставалось “вычислить” лучший ответ в 0, а время остальных ответов преобразовать в число. def best_answer_first  question.best_answer_id == id ? 0 : created_at.to_iendquestion.answers.sort_by(&amp;:best_answer_first)Пример, вожможно, не слишком удачный, так как эту задачу можно решить простым скоупом на уровне базы. А sort_by всё же достаточно медленный и лучше приберечь его для более замысловатых сортировок. ","categories": [],
        "tags": ["ruby"],
        "url": "https://arbaev.github.io/z/2019/04/23/sort_by.html"
      },{
        "title": "Идеи стартапов с сайта IndieHackers",
        "excerpt":"редакция от 27.04.2019       PowerPack for Beaver Builder, $20000/moКомплект плагинов для WordPress. Лицензия на год $69.Pausing Our Digital Agency to Build a $20k/mo WordPress Plugin         EpicPxls, $400/moМикросток темплейтов и разных дизайнерских штучекHow I Turned Design Castoffs into a Profitable Community Marketplace         KeyCuts, $250/moНаклейки на клавиатуру с шорткатами Excelемае, почему только экселя, а не всех популярных программ? Наклейки недешёвые, кстатиHow I Aligned My Side Project with a New Full-Time Career         1kprojects, $600/moБиржа вебсайтовHow I Beat Maker Paralysis with an $800/mo Side Project         Lambdatest, $50000/moВиртуальное тестирование приложений в 2000 версиях браузеров How a Software Testing Problem Led Me to 26% Monthly Growth          750words, $20000/moСервис приватного фрирайтинга. Пишешь каждый день что угодно для себя, нигде это не публикуется. Фишка в прививании ежедневной практики писания. Выполняешь задачи, зарабатываешь бейджи. Цена 5 баксов в мес. Слабо верится в 20к дохода ежемес Transforming My Simple Daily Habit into $20,000 per Month          Keygen, $3000/moАПИ для лицензирования и дистрибуции софта. How I Found My Market (and a 10% Monthly Growth Rate)    Шаблончик   , $/mo ","categories": [],
        "tags": ["идеи","ideas","стартап","startup"],
        "url": "https://arbaev.github.io/z/2019/04/27/indiehackers-ideas.html"
      },]
