var store = [{
        "title": "Rails: Настройка хранилища Amazon S3 и включение direct upload",
        "excerpt":"  Зарегистрироваться на Amazon AWS  Создать Bucket (сервис S3)  Настроить пользователя для доступа к файлам (сервис IAM)Первые три шага делаем согласно этому мануалу: Setting up Rails 5 Active Storage with Amazon S3       В config/storage.yml раскомментировать блок amazon:, указать имя бакета и псевдоним сервера. Обратить внимание на пробелы после раскомментирования строк. В каждой строке будет лишний пробел, который приводит к ошибке. Его надо удалить.         Полученные ключи доступа прописать в Rails credentials. Действуем по мануалу Rails 5.2 credentials.     Прописать в Gemgile gem AWS SDK for Ruby    gem 'aws-sdk', '~&gt; 3'# Если нужна только поддержка S3, можно установить только этот модульgem 'aws-sdk-s3', '~&gt; 1'        В файлах config/environments поменять настройку с :local на :amazon    #config.active_storage.service = :localconfig.active_storage.service = :amazon        Настроить права CORS 1) Открываем вкладку с бакетами, выбираем нужный 2) Выбрать раздел Permissions, перейти на вкладку CORS configuration 3) Вписать туда следующие строки:     &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;CORSConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\"&gt; &lt;CORSRule&gt;     &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;     &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt;     &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;     &lt;AllowedHeader&gt;Authorization&lt;/AllowedHeader&gt; &lt;/CORSRule&gt; &lt;CORSRule&gt;     &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;     &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt;     &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt;     &lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;     &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt; &lt;/CORSRule&gt; &lt;/CORSConfiguration&gt;        4) Когда разработка будет закончена, стоит поменять права на допуск только с нашего сайта, то есть заменить строки AllowedOrigin:      &lt;AllowedOrigin&gt;https://*.mysite.com&lt;/AllowedOrigin&gt;  На этом настройка S3 закончена, файлы должны успешно загружаться. Настройка direct uploads Действуем по мануалу http://rusrails.ru/active_storage_overview#pryamye-zagruzkiА именно:       К полям загрузки в форме добавить аттрибут direct_upload: true         Создать файлы direct_upload.js и direct_upload.scss с содержимым из мануала выше. Убедиться, что файлы подключились.   Прямая загрузка на S3 должна работать. ","categories": [],
        "tags": ["aws","rails"],
        "url": "https://arbaev.github.io/z/2019/04/17/rails5-amazon-s3-direct-uploads.html"
      },{
        "title": "Ruby: методы sort и sort_by",
        "excerpt":"В Ruby у класса Enumerable есть методы sort и sort_by. Первый выполняет простую сортировку массива. А вот второй более интересен.Sort_by передаёт в блок элементы один за другим, как это делает map, например. Но как, имея один объект из множества, отсортировать всё множество? Загадочный метод. В нём используется преобразование Шварца. Хитрость в том, что данные сначала проходят через наш блок и результаты вычислений заносится во временный массив попарно. Затем временный массив сортируется и получаем из него исходные данные в нужном порядке.Например, имеем массив строк: ary = ['seven', 'five', 'twelve', 'one']# отсортируем по длине строкиary.sort_by(&amp;:length)Шаг 1, сначала происходит вычисление данных во временный массив ary.map { |x| [x.length, x] } # =&gt; [[5, \"seven\"], [4, \"five\"], [6, \"twelve\"], [3, \"one\"]]Шаг 2, делается обычная сортировка ary.sort{ |x,y| x[0] &lt;=&gt; y[0] } # =&gt; [[3, \"one\"], [4, \"five\"], [5, \"seven\"], [6, \"twelve\"]]Шаг 3, получаем отсортированный массив ary.map{ |x,y| y } # =&gt; [\"one\", \"five\", \"seven\", \"twelve\"]Таким образом, можно писать замысловатые правила сортировки весьма элегантно. Например, мне надо было сделать следующую сортировку: ответы на вопрос по дате обновления, но первым должен быть лучший ответ, id которого указан в ресурсе вопроса. Для правильной сортировки мне оставалось “вычислить” лучший ответ в 0, а время остальных ответов преобразовать в число. def best_answer_first  question.best_answer_id == id ? 0 : created_at.to_iendquestion.answers.sort_by(&amp;:best_answer_first)Пример, вожможно, не слишком удачный, так как эту задачу можно решить простым скоупом на уровне базы. А sort_by всё же достаточно медленный и лучше приберечь его для более замысловатых сортировок. ","categories": [],
        "tags": ["ruby"],
        "url": "https://arbaev.github.io/z/2019/04/23/sort_by.html"
      },]
